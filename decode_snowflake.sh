#!/bin/bash
#===============================================================================
#          FILE: decode_snowflake.sh
#         USAGE: ./decode_snowflake.sh <filename>
#   DESCRIPTION: Decodes a filename generated by 'rename_files.sh' to show
#                its constituent parts (file date, unique ID components).
#  REQUIREMENTS: bash
#        AUTHOR: marcelositr - marcelost@riseup.net
#       VERSION: 1.0
#===============================================================================

# Decodes the filename and prints its components in a structured way.
decode_filename() {
    local filepath="$1"
    
    # Get just the filename without path and extension.
    # e.g., "/path/to/file.jpg" -> "file"
    local base_name
    base_name=$(basename "$filepath")
    base_name="${base_name%.*}"

    # Use IFS to split the string into variables in one go. Much cleaner than multiple 'cut' calls.
    IFS='-' read -r file_date exec_timestamp random_num static_id <<< "$base_name"

    # Validate that all parts were successfully extracted.
    if [[ -z "$file_date" || -z "$exec_timestamp" || -z "$random_num" || -z "$static_id" ]]; then
        echo "Error: Filename '$filepath' does not match the expected format."
        echo "Expected format: FileDate-ExecTimestamp-RandomNum-StaticID.extension"
        return 1
    fi

    # Print the decoded information using printf for clean, aligned output.
    echo "--- Decoded Information for: $(basename "$filepath") ---"
    printf "%-20s: %s\n" "File Date" "$file_date"
    printf "%-20s: %s\n" "Execution Timestamp" "$exec_timestamp"
    printf "%-20s: %s\n" "Random Number" "$random_num"
    printf "%-20s: %s\n" "Static Identifier" "$static_id"
    echo "----------------------------------------------------"
}

# Main execution logic.
main() {
    # Check if a filename was provided as an argument.
    if [ -z "$1" ]; then
        echo "Usage: $0 <filename>"
        exit 1
    fi

    decode_filename "$1"
}

main "$@"
